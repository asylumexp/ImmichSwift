//
// SystemConfigOAuthDto.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct SystemConfigOAuthDto: Sendable, Codable, ParameterConvertible, Hashable {

    public static let defaultStorageQuotaRule = NumericRule<Double>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    public static let timeoutRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    public var autoLaunch: Bool
    public var autoRegister: Bool
    public var buttonText: String
    public var clientId: String
    public var clientSecret: String
    public var defaultStorageQuota: Double
    public var enabled: Bool
    public var issuerUrl: String
    public var mobileOverrideEnabled: Bool
    public var mobileRedirectUri: String
    public var profileSigningAlgorithm: String
    public var scope: String
    public var signingAlgorithm: String
    public var storageLabelClaim: String
    public var storageQuotaClaim: String
    public var timeout: Int
    public var tokenEndpointAuthMethod: OAuthTokenEndpointAuthMethod

    public init(autoLaunch: Bool, autoRegister: Bool, buttonText: String, clientId: String, clientSecret: String, defaultStorageQuota: Double, enabled: Bool, issuerUrl: String, mobileOverrideEnabled: Bool, mobileRedirectUri: String, profileSigningAlgorithm: String, scope: String, signingAlgorithm: String, storageLabelClaim: String, storageQuotaClaim: String, timeout: Int, tokenEndpointAuthMethod: OAuthTokenEndpointAuthMethod) {
        self.autoLaunch = autoLaunch
        self.autoRegister = autoRegister
        self.buttonText = buttonText
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.defaultStorageQuota = defaultStorageQuota
        self.enabled = enabled
        self.issuerUrl = issuerUrl
        self.mobileOverrideEnabled = mobileOverrideEnabled
        self.mobileRedirectUri = mobileRedirectUri
        self.profileSigningAlgorithm = profileSigningAlgorithm
        self.scope = scope
        self.signingAlgorithm = signingAlgorithm
        self.storageLabelClaim = storageLabelClaim
        self.storageQuotaClaim = storageQuotaClaim
        self.timeout = timeout
        self.tokenEndpointAuthMethod = tokenEndpointAuthMethod
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case autoLaunch
        case autoRegister
        case buttonText
        case clientId
        case clientSecret
        case defaultStorageQuota
        case enabled
        case issuerUrl
        case mobileOverrideEnabled
        case mobileRedirectUri
        case profileSigningAlgorithm
        case scope
        case signingAlgorithm
        case storageLabelClaim
        case storageQuotaClaim
        case timeout
        case tokenEndpointAuthMethod
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(autoLaunch, forKey: .autoLaunch)
        try container.encode(autoRegister, forKey: .autoRegister)
        try container.encode(buttonText, forKey: .buttonText)
        try container.encode(clientId, forKey: .clientId)
        try container.encode(clientSecret, forKey: .clientSecret)
        try container.encode(defaultStorageQuota, forKey: .defaultStorageQuota)
        try container.encode(enabled, forKey: .enabled)
        try container.encode(issuerUrl, forKey: .issuerUrl)
        try container.encode(mobileOverrideEnabled, forKey: .mobileOverrideEnabled)
        try container.encode(mobileRedirectUri, forKey: .mobileRedirectUri)
        try container.encode(profileSigningAlgorithm, forKey: .profileSigningAlgorithm)
        try container.encode(scope, forKey: .scope)
        try container.encode(signingAlgorithm, forKey: .signingAlgorithm)
        try container.encode(storageLabelClaim, forKey: .storageLabelClaim)
        try container.encode(storageQuotaClaim, forKey: .storageQuotaClaim)
        try container.encode(timeout, forKey: .timeout)
        try container.encode(tokenEndpointAuthMethod, forKey: .tokenEndpointAuthMethod)
    }
}

